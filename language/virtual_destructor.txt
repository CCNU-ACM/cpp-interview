简述虚析构函数的存在意义和使用场景。



C++ 的继承模型使得子类部分和父类部分分别储存。为了保持设计上的整洁，析构子类时
会先调用子类的析构函数，再自动地析构父类部分。父类的析构仰赖父类的析构函数（或
者如果存在的话，还依赖父类的父类的析构函数）。

因此一个对象的析构必须从继承树最末端的子类的析构函数开始。然而如果指向对象的指
针或者引用不是这样的最末端子类的指针，编译器则难以得知这个析构函数的地址，造成
一部分子类部分无法被析构。

因而 C++ 要求被派生的类的析构函数应当是虚函数。由此要求编译器将继承树上的对象的
析构函数加入虚函数表。并借由重写的机制让任何一个指针析构时调用最末端子类的析构
函数。

此外，这种场景下虚析构函数因一定会被调用，而必须有其实现。将父类虚析构函数声明
为纯虚函数会导致链接问题。如果有必要这样做，可以显式的实现纯虚函数。

这个过程破坏了继承和重写的规则：析构函数是不被继承的，但虚的析构函数被重写。是
一种不优美但是合理的设计。

仅在父类需要被派生时，虚析构函数有存在的意义。对于任意类设定虚析构函数是不明智
的，这导致对象增加了一个指针空间的无用内存。
