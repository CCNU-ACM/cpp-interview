
结构体对齐的三个要点：(详情见《深入理解计算机系统》P189）
每个字段 起始位置是k的倍数,k 为sizeof
结构体整体长度为max（k）的倍数
结构体起始位置为max（k) 的倍数
x86-64的内存对齐：
1.任何内存分配函数 分配的块的起始地址是16的倍数
2.大多数函数栈帧的边界是16的倍数

编程快速求出结构体内字段偏移：https://www.zhihu.com/people/meng-yong-kang/posts

https://www.cnblogs.com/coderht/p/7436860.html
https://www.cnblogs.com/malecrab/p/5572730.html
C++对象的内存布局：虚指针和虚函数表
重点: vptr 在每个对象的最低位置,虚指针指向虚函数表
然后从低到高分别是从基类继承来的成员函数，以及本身的成员函数
每个类都有一个虚函数表(在有虚函数的情况下）
虚函数表的构建过程发生在编译时期，编译时期做的最重要的一步就是，确定这个函数在虚函数表中的偏移值；不同的对象，同样的偏移值可能对应不同的实现函数
（例如，B.foo() 和 D.foo()，B重写了继承自D的foo函数，则这两个的偏移值相同，但是两个对象有不同的虚函数表）
关于类内字段偏移和虚函数的一道很好的面试题：http://www.ahathinking.com/archives/98.html
（核心思想：类的字段存储在内存中，函数存储在其他区域；
编译器在编译时进行静态联编，确定每一个函数调用具体调用的是哪个函数（根据类型，比如b->foo(),其中b是指向类B的指针，那么就把这个foo()函数绑定到类B的成员函数foo（）中）
同时，函数中涉及对对象本身字段的操作，其中的字段会被修改成 偏移量
）
要想深入理解虚函数表，必须了解虚函数成员指针、RTTI等，推荐这个博客：
http://www.cnblogs.com/malecrab/